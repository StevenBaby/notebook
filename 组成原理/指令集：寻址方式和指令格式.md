# 指令集：寻址方式和指令格式

指令的操作数引用有两种形式：一种指令中含有操作数的实际值（立即数），二是指令中含有对操作数地址的引用。各种指令集使用类型广泛的寻址方式。这包括：

- 直接寻址：操作数地址在指令的地址字段中
- 简介寻址：地址字段指向一个存储位置，此位置含有操作数地址
- 寄存器寻址
- 寄存器间接寻址
- 各种形式的偏移地址：寄存器值加上地址值产生操作数地址。

指令格式定义了指令中字段的布局，指令格式设计是一件十分复杂的事情，要考虑到诸多因素，如指令长度是定长还是变长，指派给操作码和每个操作数引用的位数，以及如何确定寻址方式等。

## 寻址方式

指令格式中的地址字段通常是相对较小的。我们希望有能力大范围地访问主存活着虚拟存储器。为实现此目标，指令采用了各类寻址技术。他们都涉及地址范围和寻址灵活性之间，以及存储器引用计数和地址计算复杂性之间的权衡考虑。

常用寻址技术：

- 立即寻址
- 直接寻址
- 简介寻址
- 寄存器寻址
- 寄存器间接寻址
- 偏移寻址
- 栈寻址

A = 指令中地址字段内容
R = 指向寄存器的指令地址字段内容
EA = 被访问位置的实际（有效）地址
(X) = 存储器位置X或寄存器X的内容

关于有效地址，在没有虚拟存储器的系统中，有效地址将是主存地址或是寄存器地址。在虚拟存储器系统中，有效地址是虚拟地址或是寄存器，把虚拟地址映射到物理地址实际上是内存管理单元(MMU)的功能，并且是程序员不可见的。

### 立即寻址

寻址最简单的形式是立即寻址，这种方式下，操作数实际出现在指令中：

操作数 = A

这种方式能用于定义和使用常数活着设置变量的初始值。一般地，数以2的补码形式存储，最左位是符号。当操作数装入数据寄存器时，符号位向左扩展来填充数据字的字长。在某些情况下，立即二进制值被当作无符号非负整数。

立即寻址的优点是，除了取指令之外，获得的操作数不要求另外的存储器访问，于是节省了一个存储器或高速缓存周期。其缺点是数的大小受限制与地址字段的长度，而在大多数指令集中此字段长度与字长度相比是比较短的。

### 直接寻址

直接寻址也是一种很简单的寻址形式，这种方式下地址字段含有操作数的有效地址：

EA = A

此技术在早期计算机中是很普遍的，但在当代计算机体系结构中就不多见。它只要求一次存储器访问，而且不需要为生成地址的专门计算。明显的不足是只能提供有限的地址空间

### 简介寻址

直接寻址的问题是地址字段的长度通常小于字长度，这样寻址范围就很有限。一个解决方法是，让地址字段指示一个存储器字地址，而此地址处保存有操作数的全长度地址。这个被称为**简介寻址**。

EA = (A)

括号解释成，**其内容**，这种方法的明显优点是，对于N位字长来说能有$2^N$个地址可用。缺点是为取以操作数，指令执行需要访问两次存储器，第一次为得到地址，第二次才是得到他的值。

虽然能被寻址的字的数目现在等于 $2^N$，但一次能被引用的不同的有效地址数目限制到 $2^K$，这里K是地址字段的位长度，一般而言，这并不是一个严重的限制，而且可能是有益的。在虚拟存储器环境中，所有的有效地址位置都能限定放到任何进程的第0页内，因为指令的地址字段通常较小，自然会形成数目不多且数值不大的直接地址，这些地址对应的存储位置可以放在第0页中。当一个进程激活时，将会有对第0页的重复访问，这将使它保留在物理存储器中。于是，一次简介存储器的访问最多只涉及一次缺页而不是两次。

### 寄存器寻址

寄存器寻址类似于直接寻址，唯一的不同是地址字段指的是寄存器而不是一个主存地址：

EA = R

寄存器寻址的优点，一是指令中仅需要一个较小的地址字段，二是不需要存储器访问。寄存器寻址的缺点是地址空间十分有限。

若指令集中大量的使用了寄存器寻址，这意味着CPU寄存器将被大量使用。因为寄存器数量极其有限，所以只有他能得到有效使用的应用才有意义。若是每个操作数都由主存来装入寄存器，操作一次后又送回主存，则暂存这些内容实际上是一种浪费。

哪些值应该保留在寄存器中，哪些值应该存于存储器，这个判决应该由程序员或者编译器完成。大多数当代CPU都使用多个通用寄存器，如何有效地使用它们就成为了汇编语言编程人员的责任。

### 寄存器简介寻址

正如寄存器寻址类似于直接寻址一样，寄存器间接寻址也类似于简介寻址。两种情况的唯一不同是，地址字段的存储位置还是寄存器，于是对于寄存器简介寻址：

EA = (R)

寄存器间接寻址的有的和不足于简介寻址类似。二者地址空间限制都通过将地址字段指向一个保存有全长地址的位置而被客服了。另外，寄存器简介寻址比间接寻址少一次存储器访问。

### 偏移寻址

一种强有力的寻址方式是直接寻址和寄存器间接寻址能力的结合。根据上下文的不同，它由几种名称，但基本的机制是相同的。

EA = A + (R)

偏移寻址要求指令由两个地址字段，至少其中一个是显式的。保存在一个地址字段中的值直接被使用。另一个地址字段，或者一个基于操作码的隐含引用，指向一个寄存器。此寄存器的内容加上A产生有效地址

- 相对寻址

对于相对寻址，隐含引用的寄存器是程序计数器(PC), 因此也叫PC相对寻址。即当前PC的值(此指令后续的下一条指令的地址)，加上地址字段的值 A, 产生有效地址。一般地，地址字段的值在这种操作下被看成2的补码数的值，于是，有效地址是对当前指令地址的一个前后范围的偏移。

- 基址寄存器寻址

对于这种寻址方式，其解释如下：被引用的寄存器含有一个存储器地址，地址字段含有一个相对于那个地址的偏移量，寄存器引用可以是显式的，也可以是隐式的。

基址寄存器寻址也利用了存储器访问的局部性。用它来实现段是一种方便的方式。在某些方案中，采用了一个单一的段基址寄存器，并且是隐含使用。而在其他情况中，程序员可以选取一个寄存器来保存段的基地址，并且指令对它必须显式引用。在后一种情况下，若地址字段的位长度是K，并且可选取得寄存器有N个，则一条指令能访问 $N \times 2^K$ 个字得域中得任何一个字。

- 变址

对于变址，典型的解释如下：指令地址的字段引用一个主存地址，被引用的寄存器含有对于那个地址的一个正的便宜量。这种用法正好和基址寄存器寻址方式解释相反。

### 栈寻址

栈是一种位置得线性序列。有时称为下推表或后进先出队列。栈是一个预留得位置块。数据项被陆续加到栈顶，因此在任一给定时刻，栈对应得位置块是部分被填充的。

与栈相关的是一个指针，它的值是栈顶地址。

栈寻址方式是一种隐含寻址方式。机器指令不需要指明存储器引用，而是隐含地指示操作发生在栈顶。

## 指令格式

指令格式通过它的各个构成部分来定义指令的位安排。一个指令格式必须包括一个操作码，以及隐式或者显式的零个或多个操作数。指令格式必须显式或隐式地为每个操作数指定其寻址方式。

### 指令长度

设计人员面对的最基本设计出发点，是指令格式的长度。这个决定与存储器尺寸、存储器组织、总线结构、cpu复杂程度和cpu速度等相互影响。它决定了汇编语言编程人员看到的机器指令的丰富性和灵活程度。

### 位的分配

对于一个给定的指令长度，显然在操作码数目和寻址能力之间有一个权衡考虑的问题。越多的操作码名i西安意味着操作码的字段要有更多的位，这就减少了寻址可用的位数，对于这种这种考虑一个有趣的改进，是使用变长的操作码。

## 汇编语言

## 参考资料

- [1] 计算机组成与体系结构 [美] William Stallings 著
